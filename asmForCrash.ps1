<#
this is quick and dirty rewrite of previous ugly Windbg script extension https://github.com/albertlav/Repository_1/blob/master/asmChart.js
script builds Visio diagram from function asm code generated by "dis" command in crash tool (https://people.redhat.com/anderson/crash_whitepaper/)

to generate asm code, reroute dis output to file, something like
crash> dis intel_idle > intel_idle.asm

copy resulting asm file to windows box with Visio and run script on this file (or use WSL2! :))

requies installed Visio

not beautiful, but get job done..
#>

$pathtoasm="c:\1\intel_idle.asm" #put here path to text file with asm code 


$asm=Get-Content $pathtoasm

[System.Collections.ArrayList]$r1=@()
[System.Collections.ArrayList]$r=@()
[System.Collections.ArrayList]$bE=@()
[System.Collections.ArrayList]$bS=@()

$totallines=$asm.Count

#all Jcc and ret
$r=$asm | Select-String "(j[abceglmnpqxz]+(\s+)(0x[a-h0-9]{16}))|ret|retq" | Select-Object `
    @{Name="LineNumber";Expression={[int]$_.LineNumber}},`
    @{Name="BranchInstruction";Expression={[string]$(Select-String "j[abceglmnpqxz]+|retq|ret" -InputObject $_.Line).Matches[0].Value}},`
    @{Name="BranchDestination";Expression={[string]$(Select-String "0x[a-h0-9]{16}" -InputObject $_.Matches).Matches.Value}}`

$pattern=""
#create pattern and find all destinations
$pattern="^(";
$r.BranchDestination |sort | Get-Unique|%{if ($_) {$pattern+="$_|"}}
$pattern=$pattern.TrimEnd('|')+")"

$r1=$asm | Select-String "$pattern" | Select-Object @{Name="LineNumber";Expression={[int]$_.LineNumber}}

$r1|%{$bS.Add($_.LineNumber)}
$r.LineNumber|%{$bE.Add($_)}
$bE|%{if ($_+1 -le $asm.Count) {$bS.add($_+1)}}
$bS|%{$bE.Add($_-1)}
$bS.Add(1)
$bE.Add($asm.Count)
$bE = $bE | sort | Get-Unique
$bS = $bS | sort | Get-Unique



[System.Collections.ArrayList]$r=@()
$i=0
foreach ($blockstart in $bS){
    $blockend=$be[$i++]

    $branch=$(Select-String "(j[abceglmnpqxz]+(\s+)(0x[a-h0-9]{16}))|ret|retq" -InputObject $asm[$blockend-1]).Matches.Value

    $entry = New-Object -TypeName PSObject
    $entry | Add-Member -Name 'BlockStart' -MemberType Noteproperty -Value $blockstart
    $entry | Add-Member -Name 'BlockEnd' -MemberType Noteproperty -Value $blockend
    $entry | Add-Member -Name 'BlockStartAddress' -MemberType Noteproperty -Value $(Select-String "0x[a-h0-9]{16}" -InputObject $asm[$blockstart-1]).Matches[0].Value
    $entry | Add-Member -Name 'BranchDestination' -MemberType Noteproperty -Value $(Select-String "0x[a-h0-9]{16}" -InputObject $branch).Matches.Value
    $entry | Add-Member -Name 'BranchInstruction' -MemberType Noteproperty -Value $(Select-String "j[abceglmnpqxz]+|retq|ret" -InputObject $branch).Matches.Value
    $entry | Add-Member -Name 'CodeBlock' -MemberType Noteproperty -Value $asm[$($blockstart-1)..$($blockend-1)]
    $entry | Add-Member -Name 'Shape' -MemberType NoteProperty -Value ""
    $r.Add($entry)
}



$application = New-Object -ComObject Visio.Application
$documents = $application.Documents
$document = $documents.Add("")


$pages = $application.ActiveDocument.Pages
$page = $pages.Item(1)
$page.PageSheet.CellsU("PlaceStyle")=17 # hierarchy, top to bottom
$page.PageSheet.CellsU("RouteStyle")=1 #
$page.PageSheet.CellsU("LineRouteExt")=2 #curved
$document.GestureFormatSheet.CellsU("Char.Font")=$document.Fonts.Item("Consolas").ID #font to consolas
$document.GestureFormatSheet.CellsU("Char.Size").FormulaU="8 pt"
$document.GestureFormatSheet.CellsU("Para.HorzAlign")=0 #alignleft


$i=0
foreach ($block in $r){
    if ($block.CodeBlock.Length -ge 1){
        $block.Shape=$page.DrawRectangle(0+$i++,0,0,0)
        $block.Shape.Text=$block.CodeBlock | Out-String
        $($block.Shape.CellsU("Width")).FormulaU="GUARD(TEXTWIDTH(TheText))"
        $($block.Shape.CellsU("Height")).FormulaU="GUARD(TEXTHEIGHT(TheText,Width))"

<#
        #color to calls
        foreach ($m in $(Select-String "	call[q]" -InputObject $block.Shape.Text -AllMatches).Matches){
            $chr=$block.Shape.Characters
            $chr.Begin=$m.Index
            $chr.End=$m.Index+$m.length
            $chr.CharProps(1)=12
        }
        #color to branches
        foreach ($m in $(Select-String "	(j[abceglmnpqxz]+)|ret|retq" -InputObject $block.Shape.Text -AllMatches).Matches){
            $chr=$block.Shape.Characters
            $chr.Begin=$m.Index
            $chr.End=$m.Index+$m.length
            $chr.CharProps(1)=4
        }
#>
     }
}
$i=0
foreach ($block in $r){
    try{
        if ($block.BranchInstruction -notmatch "jmpq|jmp|retq|ret"){
            $block.Shape.AutoConnect($r[$i+1].Shape,0)
            $page.Shapes[$page.Shapes.Count].CellsU("EndArrow")=4  #arrow               
        }
        if ($block.BranchDestination){
            $block.Shape.AutoConnect($($r |? BlockStartAddress -eq $block.BranchDestination).Shape,0)
            $page.Shapes[$page.Shapes.Count].CellsU("LineColor")=4 #conditional connectors are blue
            $page.Shapes[$page.Shapes.Count].CellsU("EndArrow")=4  #arrow     
        }
     }catch{}
        $i++
}

$page.Layout()
$page.AutoSizeDrawing()
